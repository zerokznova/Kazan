# coding: utf-8

import os
import json
import time
import requests
from telegram import Update, InputFile, InlineKeyboardButton, InlineKeyboardMarkup
from telegram.ext import Application, CommandHandler, ContextTypes, CallbackQueryHandler

# Configurações
TOKEN = "7727164066:AAFZmMo0RSI7RqwwLKa1aTKl50nSMr2bYoI"
API_KEY = "WM3t-Av5u-thfP-GiBV-sM3B"
API_URL = "https://voidsearch.localto.net/api/search"
GRUPO_ESPECIFICO = -1002281290193
ASSINANTES_FILE = "assinantes.json"
ADMIN_ID = 7889164760
PLAN_LINK = "https://t.me/assinaturakazanova_bot"

# Bases
BASES_BASICAS = ["cpf", "nome", "telefone", "cnpj"]
BASES_AVANCADAS = [
    "rg", "rgsimpl", "pis", "titulo", "email", "cns", "mae", "pai",
    "placa", "chassi", "renavam", "motor", "fotorj", "fotosp",
    "funcionarios", "razao"
]
BASES = BASES_BASICAS + BASES_AVANCADAS

# Utilitários
def carregar_assinantes():
    if os.path.exists(ASSINANTES_FILE):
        with open(ASSINANTES_FILE, "r") as f:
            return json.load(f)
    return {}

def salvar_assinantes(assinantes):
    with open(ASSINANTES_FILE, "w") as f:
        json.dump(assinantes, f)

def tem_assinatura(user_id):
    assinantes = carregar_assinantes()
    expira = assinantes.get(str(user_id), {}).get("expira", 0)
    return time.time() < expira

# Comando /start (privado)
async def start(update: Update, context: ContextTypes.DEFAULT_TYPE):
    if update.message.chat.type != "private":
        return

    keyboard = [
        [InlineKeyboardButton("Adicionar bot ao grupo", url="https://t.me/Kazanovabuscas_bot?startgroup=true")],
        [InlineKeyboardButton("Adquirir assinatura", url=PLAN_LINK)],
        [InlineKeyboardButton("Comandos disponíveis", callback_data="show_commands")]
    ]

    await update.message.reply_text(
        "Bem-vindo ao Kazanova Bot!\n\nEste bot funciona apenas em grupos.\n\nUse os botões abaixo:",
        reply_markup=InlineKeyboardMarkup(keyboard)
    )

# Botão inline de comandos
async def handle_callback(update: Update, context: ContextTypes.DEFAULT_TYPE):
    query = update.callback_query
    await query.answer()
    data = query.data

    if data == "show_commands":
        await query.message.reply_text(
            "Comandos básicos (qualquer grupo):\n"
            "/cpf, /nome, /telefone, /cnpj\n\n"
            "Comandos avançados (grupo VIP):\n" +
            ", ".join(f"/{cmd}" for cmd in BASES_AVANCADAS)
        )

# Handler dos comandos
async def handle_comando(update: Update, context: ContextTypes.DEFAULT_TYPE):
    if not update.message:
        return

    comando = update.message.text.split()[0][1:].lower()
    argumento = " ".join(context.args)
    chat_id = update.message.chat_id

    if update.message.chat.type == "private":
        return

    if comando not in BASES:
        await update.message.reply_text("Comando inválido.")
        return

    if not argumento:
        await update.message.reply_text(f"Uso correto: /{comando} <dado>")
        return

    if comando in BASES_AVANCADAS and chat_id != GRUPO_ESPECIFICO:
        await update.message.reply_text("Este comando está disponível apenas no grupo VIP.")
        return

    await update.message.reply_text("Buscando dados, aguarde...")

    try:
        url = f"{API_URL}?Access-Key={API_KEY}&Base={comando}&Info={argumento}"
        r = requests.get(url, timeout=15)

        if r.status_code != 200 or not r.text.strip() or "error" in r.text.lower():
            await update.message.reply_text("Nenhum dado encontrado.")
            return

        texto = (
            "Consulta completa dentro do arquivo\n\n"
            f"• Base: {comando}\n"
            f"• Dado pesquisado: {argumento}\n\n"
            f"{r.text.strip()}"
        )

        nome_arquivo = f"{comando}_{argumento.replace(' ', '_')}.txt"
        caminho = f"/data/data/com.termux/files/home/Kazan/{nome_arquivo}"

        with open(caminho, "w", encoding="utf-8") as f:
            f.write(texto)

        with open(caminho, "rb") as f:
            await update.message.reply_document(
                InputFile(f, filename=nome_arquivo),
                reply_markup=InlineKeyboardMarkup([
                    [InlineKeyboardButton("Adquirir assinatura", url=PLAN_LINK)]
                ]) if comando in BASES_BASICAS and chat_id != GRUPO_ESPECIFICO else None
            )

        os.remove(caminho)

    except Exception as e:
        print("Erro:", e)
        await update.message.reply_text("Erro inesperado durante a busca.")

# Comando /liberar (admin)
async def liberar(update: Update, context: ContextTypes.DEFAULT_TYPE):
    if update.effective_user.id != ADMIN_ID:
        return

    try:
        user_id = context.args[0]
        dias = int(context.args[1])
        assinantes = carregar_assinantes()
        assinantes[user_id] = {"expira": time.time() + dias * 86400}
        salvar_assinantes(assinantes)
        await update.message.reply_text(f"Usuário {user_id} liberado por {dias} dias.")
    except:
        await update.message.reply_text("Uso correto: /liberar <user_id> <dias>")

# Inicialização
def main():
    app = Application.builder().token(TOKEN).build()

    app.add_handler(CommandHandler("start", start))
    app.add_handler(CallbackQueryHandler(handle_callback))
    app.add_handler(CommandHandler("liberar", liberar))

    for base in BASES:
        app.add_handler(CommandHandler(base, handle_comando))

    print("Bot rodando...")
    app.run_polling()

if __name__ == "__main__":
    main()
